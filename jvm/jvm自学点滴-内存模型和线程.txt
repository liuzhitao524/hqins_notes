物理计算机的并发问题：
	*缓存一致性(Cache Coherence）：缓存一致性协议
	*乱序执行（Out-Of-Order Execution）：结果与顺序执行的结果一致
Java 内存模型：
	--Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出
		出变量的这样的底层细节。（注：不包括局部变量与方法参数，因为这是线程私有的）

	--主内存（Main Memory）:所有的变量都存储在主内存（Main Memory）中。
	--工作内存（Working Memory）:每条线程有自己的工作内存（Working Memory）,线程的工作内存中保存了
		被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作
		内存中进行，而不能直接读写主内存中的变量。
	--内存间交互操作：
		Java内存模型定义了8种操作（原子的）：
		lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
		unlock（解锁）：作用于主内存的变量，它把一个处于锁定的状态的变量释放出来，释放后的变量才可以被其他线程锁定。
		read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
		load（载入）：作用于工作内存的变量，它把read操作从内存中得到的变量值放入工作内存的变量副本中。
		use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使到
			变量的值得字节码指令时将会执行这个操作。
		assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给
			变量赋值的字节码指令时执行这个操作。
		store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
		write（写入）：作用于主内存的变量，它把store操作从内存工作中得到的变量的值放到主内存的变量中。
	--volatile:
		1.线程可见性：不符合一下两条规则的运算场景中，仍需要加锁来保证原子性。
			-运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
			-变量不需要与其他的状态变量共同参与不变约束。
		2.禁止指令重拍优化。

	--三个原则： 
		原子性
		可见性
		有序性：如果在本线程内观察，所有的的操作都是有序的；如果在另一个线程中观察另一个线程，所有的操作都是无序的。
	--线程的实现： 使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。

线程安全和锁优化：
	java 语言中的线程安全：
		5类： 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立
	线程安全的实现方法：
		1.互斥同步：synchronize关键字，ReentrantLock;
		2.非阻塞同步：需要硬件指令支持，如下：	
			-测试并设置（Test-and-Set）
			-获取并增加（Fetch-and-Increment）
			-交换（Swap）
			-比较并交换（Compare and Swap(cas)）
			-加载链接/条件存储（Load-Lined/Store-Conditonal）

锁优化：
	--自旋锁与自适应自旋：为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。
	--锁清除：指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。判断依据：源于逃逸分析的数据支持。
		eg：如果判断一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。
	--锁粗化：
	--轻量级锁：
	