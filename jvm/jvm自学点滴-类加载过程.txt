类加载过程：
	加载 连接（验证、准备、解析） 初始化、使用、卸载


主动引用：
	1.遇到new、getstatic、putstatic和invokestatic四条字节码指令，如果类没有进行初始化，则需要先触发其初始化。
		（被final修饰、已在编译器把结果放入常量池的静态字段除外）
	2.使用 java.lang.reflect包的方法对类进行反射调用的时候。...
	3.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
	4.虚拟机启动，用户需要指定一个要执行的主类，虚拟机先初始化这个主类。
	5.jdk1.7动态语言支持，如果一个java.lang.invoke.MethodHandler实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄。

被动引用：	
	1.通过子类引用父类的静态字段，不会导致子类初始化；
	2.通过数组定义来引用类，不会触发此类的初始化。
	3.常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化（对应主动调用1）


类和类加载器：
	1.任意一个类，都需要由加载它的的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。
	2.每一个类加载器，都拥有一个独立的类名称空间。
	==》引申出比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义（注：
	“相等”包括代表累的Class对象的equals()方法、isAssignableFrom(）方法、isInstance()方法和instanceof关键字所做的对象关系判定）
	3.Java类随着它的类加载器一起具备了一种带有优先级的层级关系。
I

类加载器：
	1.启动类加载器 《JAVE_HOME》\lib
	2.扩展类加载器	<Java_home>\lib\ext
	3.应用程序类加载器（系统类加载器）
双亲委派模型：
	双亲委派模型被破坏的三种情形：见254-》引出线程上下文加载器（Thread Context ClassLoader）去加载JNDI接口（jdbc,jce等）提供者的代码；